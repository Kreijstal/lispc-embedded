#ifndef STDLIB_LISP_H
#define STDLIB_LISP_H

const char* stdlib_lisp = "(:\n  (def empty? (\\ (x) (= x ())))\n  (def symbol? (\\ (x) (= (type x) 'symbol)))\n  (def second (\\ (x) (_first (_rest x))))\n  (def list? (\\ (x) (= (type x) 'list)))\n\n    (def count\n	 (\\ (list)\n	  (if (empty? list)\n	      0\n	    (_+ 1 (count (_rest list))))))\n\n    (def map \n	 (\\ (f list)\n	  (if (empty? list)\n	      ()\n	    (_push (f (_first list))\n		  (map f (_rest list))))))\n\n    (def filter\n	 (\\ (pred list)\n	  (if (empty? list)\n	      ()\n	    (let ((f (_first list)))\n	      (if (pred f)\n		  (_push f (filter pred (_rest list)))\n		(filter pred (_rest list)))))))\n\n    (def reduce\n	 (\\ (f list)\n	  (if (= (count list) 1)\n	      (_first list)\n	    (f (_first list)\n	       (reduce f (_rest list))))))\n\n  (def every? (\\ (pred lst)\n    (if (empty? lst)\n      'true\n      (if (pred (_first lst))\n        (every? pred (_rest lst))\n        nil))))\n\n  (def join (\\ (lsta lstb)\n    (if (empty? lsta)\n      lstb\n      (join (_rest lsta) (_push (_first lsta) lstb)))))\n\n  (def find-by (\\ (f element lst)\n    (if (empty? lst)\n      nil\n      (if (= element (f (_first lst)))\n        (_first lst)\n        (find-by f element (_rest lst))))))\n\n    (def _generic-table '())\n    (def _generic-name _first)\n    (def _generic-fn _first)\n    (def _generic-imps second)\n    (def _generic-types second)\n\n    (def _table-update-dispatch (\\ (op fn types)\n      (list (_generic-name op) (_push (list fn types) (_generic-imps op)))))\n\n    (def _table-add! (\\ (operation)\n      (if (find-by _first operation _generic-table)\n        nil\n        (set! _generic-table\n              (_push (list operation '()) _generic-table)))))\n\n    (def _table-add-dispatch! (\\ (name fn types)\n      (if (find-by _generic-name name _generic-table)\n        (: (set! _generic-table\n                (map (\\ (generic)\n                       (if (= (_generic-name generic) name)\n                         (_table-update-dispatch generic fn types)\n                         generic))\n                     _generic-table))\n           name)\n         'no-generic)))\n\n    (def _apply-generic (\\ (name .. args)\n      (let ((generic (find-by _generic-name name _generic-table)))\n        (if generic\n          (let ((imps (_generic-imps generic))\n                (arg-types (map type args)))\n            (let ((imp (find-by _generic-types arg-types imps)))\n              (if imp\n                (apply (_generic-fn imp) args)\n                (let ((imp (filter (\\ (x) (symbol? (_generic-types x))) imps)))\n                  (if (empty? imp)\n                    'error-no-match\n                    (if (every? (\\ (x) (= x (_generic-types (_first imp)))) arg-types)\n                      (apply (_generic-fn (_first imp)) args)\n                      'error-not-all-same-type))))))\n          'error-no-oper))))\n\n    (def new-generic (\\ (name)\n      (: (_table-add! name)\n         (\\ (.. x) (apply _apply-generic (_push name x))))))\n\n    (def implement (\\ (name fn types)\n      (_table-add-dispatch! name fn types)))\n\n    (def + (new-generic '+))\n    (def - (new-generic '-))\n    (def * (new-generic '*))\n    (def < (new-generic '<))\n    (def > (new-generic '>))\n    (def <= (new-generic '<=))\n    (def >= (new-generic '>=))\n    (def % (new-generic '%))\n    (def first (new-generic 'first))\n    (def rest (new-generic 'rest))\n    (def print (new-generic 'print))\n    (implement '+ _+ 'integer)\n    (implement '- _- 'integer)\n    (implement '* _* 'integer)\n    (implement '< _< '(integer integer))\n    (implement '> _> '(integer integer))\n    (implement '<= _<= '(integer integer))\n    (implement '>= _>= '(integer integer))\n    (implement '% _% '(integer integer))\n    (implement 'first _first '(list))\n    (implement 'rest _rest '(list))\n    (implement 'print _print '(list))\n    (implement 'print _print '(integer))\n    (implement 'print _print '(procedure))\n    (implement 'print _print '(symbol)))\n";

#endif // STDLIB_LISP_H
